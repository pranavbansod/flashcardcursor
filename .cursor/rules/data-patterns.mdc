---
alwaysApply: true
---
# Data Handling Patterns

This project follows strict patterns for data handling to ensure security, type safety, and proper separation of concerns.

## Core Principles

1. **Data Retrieval** → Server Components call query helpers from `db/queries`
2. **Data Mutations** → Server Actions call mutation helpers from `db/queries`
3. **Database Operations** → All Drizzle queries are centralized in `db/queries` directory
4. **Data Validation** → Zod schemas always
5. **Type Safety** → Properly typed parameters (never use `FormData` as a type)
6. **No Direct DB Access** → Never use `db.select()`, `db.insert()`, etc. outside of `db/queries`

## Database Query Layer (`db/queries`)

All database operations **must** be centralized in the `db/queries` directory. This provides:
- **Single source of truth** for database logic
- **Reusability** across server components and actions
- **Easier testing** and maintenance
- **Type safety** with consistent return types

### Query Functions Structure

Create separate files for each entity:

```
src/
  db/
    queries/
      decks.ts    # Deck queries and mutations
      cards.ts    # Card queries and mutations
```

### Example: Deck Queries

```typescript
// db/queries/decks.ts
import { db } from "@/db";
import { decksTable } from "@/db/schema";
import { eq, and } from "drizzle-orm";

export async function getDecksByUserId(userId: string) {
  return await db
    .select()
    .from(decksTable)
    .where(eq(decksTable.userId, userId));
}

export async function getDeckById(deckId: number, userId: string) {
  const [deck] = await db
    .select()
    .from(decksTable)
    .where(and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId)
    ));
  
  return deck;
}

export async function insertDeck(data: {
  userId: string;
  name: string;
  description?: string;
}) {
  const [newDeck] = await db
    .insert(decksTable)
    .values(data)
    .returning();
  
  return newDeck;
}

export async function updateDeckById(
  deckId: number,
  userId: string,
  data: {
    name?: string;
    description?: string;
  }
) {
  const [updatedDeck] = await db
    .update(decksTable)
    .set({
      ...data,
      updatedAt: new Date(),
    })
    .where(and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId)
    ))
    .returning();
  
  return updatedDeck;
}

export async function deleteDeckById(deckId: number, userId: string) {
  await db
    .delete(decksTable)
    .where(and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId)
    ));
}
```

## Server Components for Data Retrieval

All data fetching **must** be done in Server Components using query helpers from `db/queries`. Never fetch data in Client Components or use direct database queries.

### ✅ Correct: Server Component with Query Helper

```typescript
// app/decks/page.tsx
import { currentUser } from "@clerk/nextjs/server";
import { getDecksByUserId } from "@/db/queries/decks";

export default async function DecksPage() {
  const user = await currentUser();
  
  if (!user) {
    return <div>Please sign in</div>;
  }
  
  // Use query helper from db/queries
  const decks = await getDecksByUserId(user.id);
  
  return (
    <div>
      {decks.map(deck => (
        <DeckCard key={deck.id} deck={deck} />
      ))}
    </div>
  );
}
```

### ❌ Wrong: Direct Database Access in Server Component

```typescript
// app/decks/page.tsx
import { currentUser } from "@clerk/nextjs/server";
import { db } from "@/db";
import { decksTable } from "@/db/schema";
import { eq } from "drizzle-orm";

export default async function DecksPage() {
  const user = await currentUser();
  
  if (!user) {
    return <div>Please sign in</div>;
  }
  
  // WRONG: Don't use direct database queries in components
  const decks = await db
    .select()
    .from(decksTable)
    .where(eq(decksTable.userId, user.id));
  
  return (
    <div>
      {decks.map(deck => (
        <DeckCard key={deck.id} deck={deck} />
      ))}
    </div>
  );
}
```

### ❌ Wrong: Client Component with Data Fetching

```typescript
"use client"; // DON'T DO THIS

import { useEffect, useState } from "react";

export default function DecksPage() {
  const [decks, setDecks] = useState([]);
  
  useEffect(() => {
    // WRONG: Don't fetch data in client components
    fetch("/api/decks").then(/* ... */);
  }, []);
  
  // ...
}
```

## Server Actions for Data Mutations

All database mutations (INSERT, UPDATE, DELETE) **must** be done through Server Actions that:
1. Validate input with Zod schemas
2. Authenticate the user
3. Call mutation helpers from `db/queries`

Server Actions should **never** directly use `db.insert()`, `db.update()`, or `db.delete()`.

### ✅ Correct: Server Action Using Query Helper

```typescript
// actions/deck-actions.ts
"use server";

import { z } from "zod";
import { auth } from "@clerk/nextjs/server";
import { insertDeck } from "@/db/queries/decks";
import { revalidatePath } from "next/cache";

// Define Zod schema
const createDeckSchema = z.object({
  name: z.string().min(1, "Name is required").max(100, "Name too long"),
  description: z.string().max(500).optional(),
});

// Define TypeScript type from schema
type CreateDeckInput = z.infer<typeof createDeckSchema>;

export async function createDeck(input: CreateDeckInput) {
  // 1. Validate input with Zod
  const validated = createDeckSchema.parse(input);
  
  // 2. Authenticate user
  const { userId } = await auth();
  if (!userId) {
    throw new Error("Unauthorized");
  }
  
  // 3. Call query helper from db/queries
  const newDeck = await insertDeck({
    userId,
    name: validated.name,
    description: validated.description,
  });
  
  // 4. Revalidate relevant paths
  revalidatePath("/dashboard");
  
  return newDeck;
}
```

### ✅ Correct: Update Action Using Query Helpers

```typescript
"use server";

import { z } from "zod";
import { auth } from "@clerk/nextjs/server";
import { getDeckById, updateDeckById } from "@/db/queries/decks";
import { revalidatePath } from "next/cache";

// Zod schema for validation
const updateDeckSchema = z.object({
  deckId: z.number().int().positive(),
  name: z.string().min(1).max(100).optional(),
  description: z.string().max(500).optional(),
});

// TypeScript type derived from schema
type UpdateDeckInput = z.infer<typeof updateDeckSchema>;

export async function updateDeck(input: UpdateDeckInput) {
  // 1. Validate with Zod
  const validated = updateDeckSchema.parse(input);
  
  // 2. Authenticate
  const { userId } = await auth();
  if (!userId) {
    throw new Error("Unauthorized");
  }
  
  // 3. Verify ownership using query helper
  const deck = await getDeckById(validated.deckId, userId);
  
  if (!deck) {
    throw new Error("Deck not found or access denied");
  }
  
  // 4. Update using query helper
  const updatedDeck = await updateDeckById(
    validated.deckId,
    userId,
    {
      name: validated.name,
      description: validated.description,
    }
  );
  
  // 5. Revalidate relevant paths
  revalidatePath("/dashboard");
  revalidatePath(`/decks/${validated.deckId}`);
  
  return updatedDeck;
}
```

### ✅ Correct: Delete Action Using Query Helpers

```typescript
"use server";

import { z } from "zod";
import { auth } from "@clerk/nextjs/server";
import { getDeckById, deleteDeckById } from "@/db/queries/decks";
import { revalidatePath } from "next/cache";

const deleteDeckSchema = z.object({
  deckId: z.number().int().positive(),
});

type DeleteDeckInput = z.infer<typeof deleteDeckSchema>;

export async function deleteDeck(input: DeleteDeckInput) {
  // 1. Validate
  const validated = deleteDeckSchema.parse(input);
  
  // 2. Authenticate
  const { userId } = await auth();
  if (!userId) {
    throw new Error("Unauthorized");
  }
  
  // 3. Verify ownership using query helper
  const deck = await getDeckById(validated.deckId, userId);
  
  if (!deck) {
    throw new Error("Deck not found or access denied");
  }
  
  // 4. Delete using query helper
  await deleteDeckById(validated.deckId, userId);
  
  // 5. Revalidate relevant paths
  revalidatePath("/dashboard");
  
  return { success: true };
}
```

### ❌ Wrong: Direct Database Access in Server Action

```typescript
"use server";

import { z } from "zod";
import { auth } from "@clerk/nextjs/server";
import { db } from "@/db";
import { decksTable } from "@/db/schema";

const createDeckSchema = z.object({
  name: z.string().min(1).max(100),
  description: z.string().max(500).optional(),
});

type CreateDeckInput = z.infer<typeof createDeckSchema>;

export async function createDeck(input: CreateDeckInput) {
  const validated = createDeckSchema.parse(input);
  
  const { userId } = await auth();
  if (!userId) {
    throw new Error("Unauthorized");
  }
  
  // WRONG: Don't use direct database queries in actions
  const [newDeck] = await db
    .insert(decksTable)
    .values({
      userId,
      name: validated.name,
      description: validated.description,
    })
    .returning();
  
  return newDeck;
}
```

### ❌ Wrong: Unvalidated Server Action

```typescript
"use server";

// WRONG: No Zod validation, no proper types
export async function updateDeck(deckId: number, name: string) {
  // Missing validation!
  // Missing auth check!
  // Missing query helper usage!
  await db.update(decksTable).set({ name }).where(eq(decksTable.id, deckId));
}
```

### ❌ Wrong: Using FormData as Type

```typescript
"use server";

// WRONG: Don't use FormData as the parameter type
export async function createDeck(formData: FormData) {
  const name = formData.get("name");
  // ...
}
```

Instead, extract and validate FormData in the client, then pass typed data:

```typescript
// Client component
"use client";

import { createDeck } from "@/actions/deck-actions";

export function CreateDeckForm() {
  async function handleSubmit(formData: FormData) {
    // Extract data
    const data = {
      name: formData.get("name") as string,
      description: formData.get("description") as string,
    };
    
    // Pass typed data to server action
    await createDeck(data);
  }
  
  return <form action={handleSubmit}>...</form>;
}
```

## Calling Server Actions from Client Components

Client components can call server actions for mutations, but must pass properly typed data:

```typescript
"use client";

import { useState } from "react";
import { createDeck } from "@/actions/deck-actions";
import { Button } from "@/components/ui/button";

export function CreateDeckButton() {
  const [isLoading, setIsLoading] = useState(false);
  
  async function handleCreate() {
    setIsLoading(true);
    try {
      // Pass properly typed object
      await createDeck({
        name: "New Deck",
        description: "My new flashcard deck",
      });
    } catch (error) {
      console.error("Failed to create deck:", error);
    } finally {
      setIsLoading(false);
    }
  }
  
  return (
    <Button onClick={handleCreate} disabled={isLoading}>
      Create Deck
    </Button>
  );
}
```

## File Organization

Organize code with clear separation of concerns:

```
src/
  db/
    queries/
      decks.ts         # Deck database queries and mutations
      cards.ts         # Card database queries and mutations
  actions/
    deck-actions.ts    # Deck server actions (validation + auth + query helpers)
    card-actions.ts    # Card server actions (validation + auth + query helpers)
  app/
    decks/
      page.tsx         # Server component using query helpers
      [id]/
        page.tsx       # Server component using query helpers
  components/
    deck-form.tsx      # Client component that calls server actions
```

### Layer Responsibilities

1. **`db/queries`** - Database operations only
   - Pure database queries using Drizzle
   - No authentication logic
   - No validation logic
   - Export reusable query functions
   
2. **`actions`** - Business logic and orchestration
   - Validate inputs with Zod
   - Authenticate users
   - Call query helpers from `db/queries`
   - Revalidate paths when needed
   - Handle errors
   
3. **`app` (Server Components)** - Data retrieval
   - Authenticate users
   - Call query helpers from `db/queries`
   - Render UI with fetched data
   
4. **`components` (Client Components)** - User interaction
   - Handle user input
   - Call server actions
   - Manage UI state

## Checklist for Every Feature

When implementing a feature:

- [ ] Database queries are in `db/queries` directory
- [ ] No direct `db.select()`, `db.insert()`, `db.update()`, `db.delete()` calls outside `db/queries`
- [ ] Data retrieval is in a Server Component using query helpers
- [ ] Mutations use Server Actions marked with `"use server"`
- [ ] Server actions call query helpers from `db/queries`
- [ ] Zod schema is defined for all server action inputs
- [ ] TypeScript type is derived from Zod schema using `z.infer<typeof schema>`
- [ ] Input validation uses `schema.parse(input)` or `schema.safeParse(input)`
- [ ] Server actions verify user authentication
- [ ] Server actions verify resource ownership (via query helpers)
- [ ] No `FormData` used as a parameter type
- [ ] Client components pass properly typed objects to server actions
- [ ] Server actions call `revalidatePath()` after mutations

## Error Handling

Use `safeParse` for user-friendly error handling:

```typescript
"use server";

import { z } from "zod";

const schema = z.object({
  name: z.string().min(1, "Name is required"),
});

type Input = z.infer<typeof schema>;

export async function myAction(input: Input) {
  const result = schema.safeParse(input);
  
  if (!result.success) {
    return {
      success: false,
      error: result.error.format(),
    };
  }
  
  // Proceed with validated data
  const validated = result.data;
  
  // ... perform action
  
  return { success: true };
}
```

## Summary

| Operation | Location | Database Layer | Validation | Type Safety |
|-----------|----------|----------------|------------|-------------|
| **Read** (SELECT) | Server Component | `db/queries` helper | N/A | TypeScript |
| **Create** (INSERT) | Server Action | `db/queries` helper | Zod | z.infer<typeof schema> |
| **Update** (UPDATE) | Server Action | `db/queries` helper | Zod | z.infer<typeof schema> |
| **Delete** (DELETE) | Server Action | `db/queries` helper | Zod | z.infer<typeof schema> |

### Data Flow

```
Client Component
       ↓
Server Action (validation + auth)
       ↓
db/queries helper (database operation)
       ↓
Database
```

```
Server Component (auth)
       ↓
db/queries helper (database operation)
       ↓
Database
```

### Key Rules

1. **All database operations** go through `db/queries` helpers
2. **Never use** `db.select()`, `db.insert()`, `db.update()`, `db.delete()` outside `db/queries`
3. **Always validate** inputs with Zod in server actions
4. **Always authenticate** users before database operations
5. **Always revalidate** paths after mutations
